<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Chess Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            padding: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .game-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .board-container {
           position: relative;
           display: flex;
            align-items: center;
           margin-left: 25px; /* Add space for rank labels */
            margin-bottom: 25px; /* Add space for file labels */
        }

            .coordinates {
            position: absolute;
            font-size: 14px;
            color: #555;
            font-weight: bold;
        }

        .file-coordinates {
            position: absolute;
            bottom: -25px;
            left: 0;
            display: flex;
            width: 480px; /* 8 squares × 60px */
        }

        .file-coordinates span {
            width: 60px;
            text-align: center;
        }

        .rank-coordinates {
            position: absolute;
            top: 0;
            left: -25px;
            display: flex;
            flex-direction: column;
            height: 480px; /* 8 squares × 60px */
        }

        .rank-coordinates span {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Added styles for clocks */
        .clocks {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 480px;
            margin: 10px 0;
        }
        
        .clock {
            background-color: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 24px;
            font-family: monospace;
            min-width: 120px;
            text-align: center;
        }
        
        .clock.active {
            background-color: #4CAF50;
        }
        
        /* Styles for theme selector */
        .theme-selector {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .theme-options {
            display: flex;
            gap: 10px;
        }
        
        .theme-option {
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .theme-option.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.selected {
            background-color: #aec6cf;
        }
        
        .square.valid-move {
            position: relative;
        }
        
        .square.valid-move::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            z-index: 1;
        }
        
        .square.valid-capture::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 5px solid rgba(255, 0, 0, 0.3);
            border-radius: 0;
            z-index: 1;
        }
        
        .square.check {
            background-color: #ff6666 !important;
        }
        
        .controls {
            margin-top: 30px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .game-info {
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            min-width: 300px;
        }
        
        .move-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            width: 100%;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 10px;
        }
        
        .move-number {
            font-weight: bold;
        }
        
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .promotion-options {
            display: flex;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .promotion-piece {
            font-size: 48px;
            margin: 0 10px;
            cursor: pointer;
            padding: 10px;
            border-radius: 4px;
        }
        
        .promotion-piece:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <h1>Chess Game</h1>
    
    <div class="game-container">
        <!-- Chess clocks -->
        <div class="clocks">
            <div class="clock" id="black-clock">10:00</div>
            <div class="clock active" id="white-clock">10:00</div>
        </div>
        
        <div class="board-container">
            <div class="rank-coordinates">
                <span>8</span>
                <span>7</span>
                <span>6</span>
                <span>5</span>
                <span>4</span>
                <span>3</span>
                <span>2</span>
                <span>1</span>
            </div>
            <div class="board" id="chessboard"></div>
            <div class="file-coordinates">
                <span>a</span>
                <span>b</span>
                <span>c</span>
                <span>d</span>
                <span>e</span>
                <span>f</span>
                <span>g</span>
                <span>h</span>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="reset-btn">New Game</button>
        <button id="undo-btn">Undo Move</button>
        <button id="ai-move-btn">AI Move</button>
        <button id="save-btn">Save Game</button>
        <button id="load-btn">Load Game</button>
        <button id="export-pgn-btn">Export PGN</button>
        <button id="import-fen-btn">Import FEN</button>
    </div>
    
    <div class="theme-selector">
        <label>Board Theme:</label>
        <div class="theme-options">
            <div class="theme-option active" data-theme="classic">Classic</div>
            <div class="theme-option" data-theme="blue">Blue</div>
            <div class="theme-option" data-theme="green">Green</div>
            <div class="theme-option" data-theme="red">Red</div>
        </div>
    </div>
    
    <div class="game-info">
        <p>Current Turn: <span id="current-turn">White</span></p>
        <p>Status: <span id="game-status">In Progress</span></p>
    </div>
    
    <div class="move-history">
        <h3>Move History</h3>
        <div class="move-list" id="move-list">
            <!-- Move history will be populated here -->
        </div>
    </div>
    
    <div class="promotion-modal" id="promotion-modal">
        <div class="promotion-options">
            <div class="promotion-piece" data-piece="queen">♕</div>
            <div class="promotion-piece" data-piece="rook">♖</div>
            <div class="promotion-piece" data-piece="bishop">♗</div>
            <div class="promotion-piece" data-piece="knight">♘</div>
        </div>
    </div>
    
    <script>
        // Chess piece Unicode symbols
        const PIECES = {
            'white': {
                'king': '♔',
                'queen': '♕',
                'rook': '♖',
                'bishop': '♗',
                'knight': '♘',
                'pawn': '♙'
            },
            'black': {
                'king': '♚',
                'queen': '♛',
                'rook': '♜',
                'bishop': '♝',
                'knight': '♞',
                'pawn': '♟'
            }
        };
        
        // Game state
        let board = [];
        let currentPlayer = 'white';
        let selectedPiece = null;
        let validMoves = [];
        let gameHistory = [];
        let moveHistory = [];
        
        // Clock settings
        let clockEnabled = true;
        let clockTime = {
            white: 10 * 60, // 10 minutes in seconds
            black: 10 * 60
        };
        let activeTimer;
        let clockIntervalId;
        
        // Theme settings
        let currentTheme = 'classic';
        const themes = {
            classic: {
                light: '#f0d9b5',
                dark: '#b58863',
                selected: '#aec6cf',
                check: '#ff6666'
            },
            blue: {
                light: '#cad9e3',
                dark: '#6c8eaf',
                selected: '#a8c5d8',
                check: '#ff6666'
            },
            green: {
                light: '#e8f0cc',
                dark: '#769656',
                selected: '#a9c786',
                check: '#ff6666'
            },
            red: {
                light: '#f2c1b9',
                dark: '#ad4d43',
                selected: '#d88a80',
                check: '#4c72e0'
            }
        };
        
        // Special move flags
        let kings = {
            'white': { row: 7, col: 4, moved: false },
            'black': { row: 0, col: 4, moved: false }
        };
        
        let rooks = {
            'white': {
                'kingside': { row: 7, col: 7, moved: false },
                'queenside': { row: 7, col: 0, moved: false }
            },
            'black': {
                'kingside': { row: 0, col: 7, moved: false },
                'queenside': { row: 0, col: 0, moved: false }
            }
        };
        
        let lastMove = null;
        let enPassantTarget = null;
        let promotionPending = null;
        
        // Initialize the board
        function initializeBoard() {
            // Standard chess starting position
            importFEN('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
            
            // Reset clocks
            clockTime = {
                white: 10 * 60,
                black: 10 * 60
            };
            
            // Reset game state
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            gameHistory = [];
            moveHistory = [];
            
            // Reset special move flags
            kings = {
                'white': { row: 7, col: 4, moved: false },
                'black': { row: 0, col: 4, moved: false }
            };
            
            rooks = {
                'white': {
                    'kingside': { row: 7, col: 7, moved: false },
                    'queenside': { row: 7, col: 0, moved: false }
                },
                'black': {
                    'kingside': { row: 0, col: 7, moved: false },
                    'queenside': { row: 0, col: 0, moved: false }
                }
            };
            
            lastMove = null;
            enPassantTarget = null;
            promotionPending = null;
            
            updateBoard();
            updateGameInfo();
            updateMoveHistory();
        }
        
        // Convert board position to algebraic notation
        function toAlgebraic(row, col) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            return files[col] + ranks[row];
        }
        
        // Convert algebraic notation to board position
        function fromAlgebraic(algebraic) {
            const files = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7};
            const ranks = {'8': 0, '7': 1, '6': 2, '5': 3, '4': 4, '3': 5, '2': 6, '1': 7};
            return {
                row: ranks[algebraic[1]],
                col: files[algebraic[0]]
            };
        }
        
        // Generate move in algebraic notation
        function generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, capture, specialMove = null, promotion = null) {
            const pieceSymbols = {
                'king': 'K',
                'queen': 'Q',
                'rook': 'R',
                'bishop': 'B',
                'knight': 'N',
                'pawn': ''
            };
            
            let notation = '';
            
            // Special moves
            if (specialMove === 'castling-kingside') {
                return 'O-O';
            } else if (specialMove === 'castling-queenside') {
                return 'O-O-O';
            }
            
            // Piece letter (except for pawns)
            notation += pieceSymbols[piece.type];
            
            // Check for disambiguation
            if (piece.type !== 'pawn' && piece.type !== 'king') {
                let sameTypePieces = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (r === fromRow && c === fromCol) continue;
                        const otherPiece = board[r][c];
                        if (otherPiece && otherPiece.type === piece.type && otherPiece.color === piece.color) {
                            const otherMoves = getValidMovesForPiece(r, c, true);
                            if (otherMoves.some(move => move.row === toRow && move.col === toCol)) {
                                sameTypePieces.push({ row: r, col: c });
                            }
                        }
                    }
                }
                
                if (sameTypePieces.length > 0) {
                    // Check if file disambiguation is enough
                    const sameFile = sameTypePieces.some(p => p.col === fromCol);
                    const sameRank = sameTypePieces.some(p => p.row === fromRow);
                    
                    if (!sameFile) {
                        notation += toAlgebraic(fromRow, fromCol)[0]; // Add file
                    } else if (!sameRank) {
                        notation += toAlgebraic(fromRow, fromCol)[1]; // Add rank
                    } else {
                        notation += toAlgebraic(fromRow, fromCol); // Add both
                    }
                }
            }
            
            // Pawn captures need the file
            if (piece.type === 'pawn' && capture) {
                notation += toAlgebraic(fromRow, fromCol)[0];
            }
            
            // Capture symbol
            if (capture) {
                notation += 'x';
            }
            
            // Destination square
            notation += toAlgebraic(toRow, toCol);
            
            // Pawn promotion
            if (promotion) {
                notation += '=' + pieceSymbols[promotion].toUpperCase();
            }
            
            // Check for check or checkmate
            // This will be added later after the move is made
            
            return notation;
        }
        
        // Render the board
        function updateBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.style.backgroundColor = isLight ? 
                        getComputedStyle(document.documentElement).getPropertyValue('--light-square') : 
                        getComputedStyle(document.documentElement).getPropertyValue('--dark-square');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Check if king is in check
                    const piece = board[row][col];
                    if (piece && piece.type === 'king') {
                        if (isKingInCheck(piece.color)) {
                            square.classList.add('check');
                            square.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--check');
                        }
                    }
                    
                    if (piece) {
                        square.textContent = PIECES[piece.color][piece.type];
                    }
                    
                    // Add selected class if this is the selected piece
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                        square.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--selected');
                    }
                    
                    // Add valid-move class if this is a valid move
                    const validMove = validMoves.find(move => move.row === row && move.col === col);
                    if (validMove) {
                        square.classList.add('valid-move');
                        if (validMove.capture) {
                            square.classList.add('valid-capture');
                        }
                    }
                    
                    square.addEventListener('click', handleSquareClick);
                    chessboard.appendChild(square);
                }
            }
        }
        
        // Handle square click
        function handleSquareClick(event) {
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            // If there's a pending promotion, ignore clicks
            if (promotionPending) return;
            
            // If a piece is already selected
            if (selectedPiece) {
                // Check if the clicked square is a valid move
                const validMove = validMoves.find(move => move.row === row && move.col === col);
                
                if (validMove) {
                    // Save current state to history
                    saveGameState();
                    
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];
                    
                    // Check for pawn promotion
                    if (piece.type === 'pawn' && (row === 0 || row === 7)) {
                        promotionPending = {
                            fromRow,
                            fromCol,
                            toRow: row,
                            toCol: col,
                            capture: validMove.capture,
                            enPassant: validMove.enPassant
                        };
                        showPromotionModal();
                        return;
                    }
                    
                    // Make the move
                    makeMove(fromRow, fromCol, row, col, validMove);
                } else {
                    // If clicking on own piece, select it
                    const piece = board[row][col];
                    if (piece && piece.color === currentPlayer) {
                        selectedPiece = { row, col };
                        validMoves = getValidMovesForPiece(row, col);
                        updateBoard();
                    } else {
                        // Invalid selection, reset
                        selectedPiece = null;
                        validMoves = [];
                        updateBoard();
                    }
                }
            } else {
                // No piece selected yet
                const piece = board[row][col];
                if (piece && piece.color === currentPlayer) {
                    selectedPiece = { row, col };
                    validMoves = getValidMovesForPiece(row, col);
                    updateBoard();
                }
            }
        }
        
        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol, moveDetails, promotionPiece = null) {
            const piece = board[fromRow][fromCol];
            const target = board[toRow][toCol];
            const isCapture = !!target || (moveDetails && moveDetails.enPassant);
            const isCastling = piece.type === 'king' && Math.abs(fromCol - toCol) > 1;
            let specialMove = null;
            
            // Stop and restart clock when a move is made
            stopClock();
            
            // Record the move
            lastMove = {
                piece,
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                capture: isCapture,
                promotion: promotionPiece
            };
            
            // Handle castling
            if (isCastling) {
                const isKingside = toCol > fromCol;
                specialMove = isKingside ? 'castling-kingside' : 'castling-queenside';
                
                // Move the rook
                const rookCol = isKingside ? 7 : 0;
                const newRookCol = isKingside ? 5 : 3;
                const rookPiece = board[fromRow][rookCol];
                
                board[fromRow][rookCol] = null;
                board[fromRow][newRookCol] = rookPiece;
                
                // Update rook moved status
                if (piece.color === 'white') {
                    rooks[piece.color][isKingside ? 'kingside' : 'queenside'].moved = true;
                } else {
                    rooks[piece.color][isKingside ? 'kingside' : 'queenside'].moved = true;
                }
            }
            
            // Handle en passant capture
            if (moveDetails && moveDetails.enPassant) {
                const captureRow = fromRow;
                const captureCol = toCol;
                board[captureRow][captureCol] = null;
            }
            
            // Check for en passant possibility on next move
            enPassantTarget = null;
            if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {
                enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
            }
            
            // Handle promotion
            if (promotionPiece) {
                board[fromRow][fromCol] = null;
                board[toRow][toCol] = { type: promotionPiece, color: piece.color };
            } else {
                // Move the piece
                board[fromRow][fromCol] = null;
                board[toRow][toCol] = piece;
            }
            
            // Update king position and moved status
            if (piece.type === 'king') {
                kings[piece.color].row = toRow;
                kings[piece.color].col = toCol;
                kings[piece.color].moved = true;
            }
            
            // Update rook moved status
            if (piece.type === 'rook') {
                if (piece.color === 'white') {
                    if (fromRow === 7 && fromCol === 0) {
                        rooks.white.queenside.moved = true;
                    } else if (fromRow === 7 && fromCol === 7) {
                        rooks.white.kingside.moved = true;
                    }
                } else {
                    if (fromRow === 0 && fromCol === 0) {
                        rooks.black.queenside.moved = true;
                    } else if (fromRow === 0 && fromCol === 7) {
                        rooks.black.kingside.moved = true;
                    }
                }
            }
            
            // Generate notation and add to move history
            let notation = generateMoveNotation(fromRow, fromCol, toRow, toCol, piece, isCapture, specialMove, promotionPiece);
            
            // Check if the move results in check or checkmate
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            
            // Switch players
            currentPlayer = opponentColor;
            
            // Check for check
            const isCheck = isKingInCheck(opponentColor);
            if (isCheck) {
                notation += '+';
                
                // Check for checkmate
                const isCheckmate = isKingInCheckmate(opponentColor);
                if (isCheckmate) {
                    notation = notation.replace('+', '#');
                }
            }
            
            // Add move to history
            moveHistory.push(notation);
            
            // Reset selection
            selectedPiece = null;
            validMoves = [];
            promotionPending = null;
            
            updateBoard();
            updateGameInfo();
            updateMoveHistory();
            checkGameStatus();
            updateClocks();
            startClock();
            
            // If AI is active and it's black's turn, make AI move
            if (currentPlayer === 'black' && document.getElementById('ai-move-btn').textContent === 'Disable AI') {
                // Small delay to make the AI move appear natural
                setTimeout(makeAIMove, 500);
            }
        }
        
        // Save the current game state
        function saveGameState() {
            const state = {
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer,
                kings: JSON.parse(JSON.stringify(kings)),
                rooks: JSON.parse(JSON.stringify(rooks)),
                enPassantTarget,
                moveHistory: [...moveHistory]
            };
            
            gameHistory.push(state);
        }
        
        // Show promotion modal
        function showPromotionModal() {
            const modal = document.getElementById('promotion-modal');
            modal.style.display = 'flex';
            
            // Set piece colors to match the current player
            const promotionPieces = modal.querySelectorAll('.promotion-piece');
            promotionPieces.forEach(element => {
                if (currentPlayer === 'white') {
                    element.textContent = PIECES.white[element.dataset.piece];
                } else {
                    element.textContent = PIECES.black[element.dataset.piece];
                }
                
                element.onclick = () => handlePromotion(element.dataset.piece);
            });
        }
        
        // Handle promotion selection
        function handlePromotion(pieceType) {
            const modal = document.getElementById('promotion-modal');
            modal.style.display = 'none';
            
            if (!promotionPending) return;
            
            const { fromRow, fromCol, toRow, toCol, capture, enPassant } = promotionPending;
            
            makeMove(fromRow, fromCol, toRow, toCol, { capture, enPassant }, pieceType);
        }
        
        // Get valid moves for a piece
        function getValidMovesForPiece(row, col, checkingDisambiguation = false) {
            const piece = board[row][col];
            if (!piece) return [];
            
            let moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    moves = getPawnMoves(row, col, piece.color);
                    break;
                case 'knight':
                    moves = getKnightMoves(row, col, piece.color);
                    break;
                case 'bishop':
                    moves = getBishopMoves(row, col, piece.color);
                    break;
                case 'rook':
                    moves = getRookMoves(row, col, piece.color);
                    break;
                case 'queen':
                    moves = getQueenMoves(row, col, piece.color);
                    break;
                case 'king':
                    moves = getKingMoves(row, col, piece.color);
                    break;
            }
            
            // Filter out moves that would put or leave the king in check
            if (!checkingDisambiguation) {
                moves = moves.filter(move => !wouldMoveResultInCheck(row, col, move.row, move.col, piece.color));
            }
            
            return moves;
        }
        
        // Check if a move would result in the king being in check
        function wouldMoveResultInCheck(fromRow, fromCol, toRow, toCol, color) {
            // Create a temporary board to simulate the move
            const tempBoard = JSON.parse(JSON.stringify(board));
            const piece = tempBoard[fromRow][fromCol];
            
            // Special handling for en passant
            let capturedPawnPosition = null;
            if (piece.type === 'pawn' && enPassantTarget && 
                enPassantTarget.row === toRow && enPassantTarget.col === toCol) {
                capturedPawnPosition = { row: fromRow, col: toCol };
            }
            
            // Make the move on the temporary board
            tempBoard[fromRow][fromCol] = null;
            tempBoard[toRow][toCol] = piece;
            
            // If this is an en passant capture, remove the captured pawn
            if (capturedPawnPosition) {
                tempBoard[capturedPawnPosition.row][capturedPawnPosition.col] = null;
            }
            
            // Find the king's position
            let kingRow = kings[color].row;
            let kingCol = kings[color].col;
            
            // If the moved piece is the king, update its position
            if (piece.type === 'king') {
                kingRow = toRow;
                kingCol = toCol;
            }
            
            // Check if any opponent piece can capture the king
            const opponentColor = color === 'white' ? 'black' : 'white';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceOnSquare = tempBoard[r][c];
                    if (pieceOnSquare && pieceOnSquare.color === opponentColor) {
                        // Check if this piece can attack the king
                        const canAttackKing = canPieceAttack(r, c, kingRow, kingCol, pieceOnSquare.type, opponentColor, tempBoard);
                        if (canAttackKing) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Check if a piece can attack a specific square
        function canPieceAttack(fromRow, fromCol, toRow, toCol, pieceType, pieceColor, boardState) {
            switch (pieceType) {
                case 'pawn':
                    // Pawns attack diagonally
                    const direction = pieceColor === 'white' ? -1 : 1;
                    return (fromRow + direction === toRow) && (Math.abs(fromCol - toCol) === 1);
                
                case 'knight':
                    // Knights move in L-shape
                    const rowDiff = Math.abs(fromRow - toRow);
                    const colDiff = Math.abs(fromCol - toCol);
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                
                case 'bishop':
                    // Bishops move diagonally
                    if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
                    
                    // Check if path is clear
                    const bishopRowStep = fromRow < toRow ? 1 : -1;
                    const bishopColStep = fromCol < toCol ? 1 : -1;
                    
                    let r = fromRow + bishopRowStep;
                    let c = fromCol + bishopColStep;
                    
                    while (r !== toRow && c !== toCol) {
                        if (boardState[r][c]) return false;
                        r += bishopRowStep;
                        c += bishopColStep;
                    }
                    
                    return true;
                
                case 'rook':
                    // Rooks move horizontally or vertically
                    if (fromRow !== toRow && fromCol !== toCol) return false;
                    
                    // Check if path is clear
                    if (fromRow === toRow) {
                        // Horizontal move
                        const step = fromCol < toCol ? 1 : -1;
                        for (let c = fromCol + step; c !== toCol; c += step) {
                            if (boardState[fromRow][c]) return false;
                        }
                    } else {
                        // Vertical move
                        const step = fromRow < toRow ? 1 : -1;
                        for (let r = fromRow + step; r !== toRow; r += step) {
                            if (boardState[r][fromCol]) return false;
                        }
                    }
                    
                    return true;
                
                case 'queen':
                    // Queens move like rooks or bishops
                    const diagonalMove = Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol);
                    const straightMove = fromRow === toRow || fromCol === toCol;
                    
                    if (!diagonalMove && !straightMove) return false;
                    
                    if (diagonalMove) {
                        // Diagonal move
                        const rowStep = fromRow < toRow ? 1 : -1;
                        const colStep = fromCol < toCol ? 1 : -1;
                        
                        let r = fromRow + rowStep;
                        let c = fromCol + colStep;
                        
                        while (r !== toRow && c !== toCol) {
                            if (boardState[r][c]) return false;
                            r += rowStep;
                            c += colStep;
                        }
                    } else {
                        // Straight move
                        if (fromRow === toRow) {
                            // Horizontal
                            const step = fromCol < toCol ? 1 : -1;
                            for (let c = fromCol + step; c !== toCol; c += step) {
                                if (boardState[fromRow][c]) return false;
                            }
                        } else {
                            // Vertical
                            const step = fromRow < toRow ? 1 : -1;
                            for (let r = fromRow + step; r !== toRow; r += step) {
                                if (boardState[r][fromCol]) return false;
                            }
                        }
                    }
                    
                    return true;
                
                case 'king':
                    // Kings move one square in any direction
                    return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
                
                default:
                    return false;
            }
        }
        
        // Check if a king is in check
        function isKingInCheck(color) {
            const kingRow = kings[color].row;
            const kingCol = kings[color].col;
            const opponentColor = color === 'white' ? 'black' : 'white';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === opponentColor) {
                        if (canPieceAttack(row, col, kingRow, kingCol, piece.type, opponentColor, board)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Check if a king is in checkmate
        function isKingInCheckmate(color) {
            // If the king is not in check, it's not checkmate
            if (!isKingInCheck(color)) return false;
            
            // Check if any move can get the king out of check
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMovesForPiece(row, col);
                        if (validMoves.length > 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Check if the game is a stalemate
        function isStalemate(color) {
            // If the king is in check, it's not stalemate
            if (isKingInCheck(color)) return false;
            
            // Check if any piece can make a legal move
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMovesForPiece(row, col);
                        if (validMoves.length > 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Get valid moves for a pawn
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startingRow = color === 'white' ? 6 : 1;
            
            // Move forward one square
            if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {
                moves.push({ row: row + direction, col: col });
                
                // Move forward two squares from starting position
                if (row === startingRow && !board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col: col });
                }
            }
            
            // Capture diagonally
            const captureCols = [col - 1, col + 1];
            for (const captureCol of captureCols) {
                if (captureCol >= 0 && captureCol < 8) {
                    const captureRow = row + direction;
                    if (captureRow >= 0 && captureRow < 8) {
                        const target = board[captureRow][captureCol];
                        if (target && target.color !== color) {
                            moves.push({ row: captureRow, col: captureCol, capture: true });
                        }
                        
                        // En passant capture
                        if (!target && enPassantTarget && 
                            enPassantTarget.row === captureRow && 
                            enPassantTarget.col === captureCol) {
                            moves.push({ 
                                row: captureRow, 
                                col: captureCol, 
                                capture: true,
                                enPassant: true
                            });
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a knight
        function getKnightMoves(row, col, color) {
            const moves = [];
            const knightMoves = [
                { row: -2, col: -1 }, { row: -2, col: 1 },
                { row: -1, col: -2 }, { row: -1, col: 2 },
                { row: 1, col: -2 }, { row: 1, col: 2 },
                { row: 2, col: -1 }, { row: 2, col: 1 }
            ];
            
            for (const move of knightMoves) {
                const newRow = row + move.row;
                const newCol = col + move.col;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else if (target.color !== color) {
                        moves.push({ row: newRow, col: newCol, capture: true });
                    }
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a bishop
        function getBishopMoves(row, col, color) {
            const moves = [];
            const directions = [
                { row: -1, col: -1 }, // up-left
                { row: -1, col: 1 },  // up-right
                { row: 1, col: -1 },  // down-left
                { row: 1, col: 1 }    // down-right
            ];
            
            for (const direction of directions) {
                let newRow = row + direction.row;
                let newCol = col + direction.col;
                
                while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                        break; // Stop in this direction if we hit a piece
                    }
                    
                    newRow += direction.row;
                    newCol += direction.col;
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a rook
        function getRookMoves(row, col, color) {
            const moves = [];
            const directions = [
                { row: -1, col: 0 }, // up
                { row: 1, col: 0 },  // down
                { row: 0, col: -1 }, // left
                { row: 0, col: 1 }   // right
            ];
            
            for (const direction of directions) {
                let newRow = row + direction.row;
                let newCol = col + direction.col;
                
                while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                        break; // Stop in this direction if we hit a piece
                    }
                    
                    newRow += direction.row;
                    newCol += direction.col;
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a queen
        function getQueenMoves(row, col, color) {
            // Queen combines rook and bishop movements
            return [
                ...getRookMoves(row, col, color),
                ...getBishopMoves(row, col, color)
            ];
        }
        
        // Get valid moves for a king
        function getKingMoves(row, col, color) {
            const moves = [];
            
            // Standard king moves (one square in any direction)
            for (let r = -1; r <= 1; r++) {
                for (let c = -1; c <= 1; c++) {
                    if (r === 0 && c === 0) continue; // Skip the current position
                    
                    const newRow = row + r;
                    const newCol = col + c;
                    
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = board[newRow][newCol];
                        
                        if (!target) {
                            moves.push({ row: newRow, col: newCol });
                        } else if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
            }
            
            // Castling
            if (!kings[color].moved && !isKingInCheck(color)) {
                // Kingside castling
                if (!rooks[color].kingside.moved) {
                    let canCastle = true;
                    
                    // Check if squares between king and rook are empty
                    for (let c = col + 1; c < 7; c++) {
                        if (board[row][c]) {
                            canCastle = false;
                            break;
                        }
                    }
                    
                    // Check if king passes through check
                    if (canCastle) {
                        const tempBoard = JSON.parse(JSON.stringify(board));
                        tempBoard[row][col] = null;
                        
                        // Check if king passes through check
                        if (wouldSquareBeAttacked(row, col + 1, color, tempBoard) ||
                            wouldSquareBeAttacked(row, col + 2, color, tempBoard)) {
                            canCastle = false;
                        }
                    }
                    
                    if (canCastle) {
                        moves.push({ row: row, col: col + 2, castling: 'kingside' });
                    }
                }
                
                // Queenside castling
                if (!rooks[color].queenside.moved) {
                    let canCastle = true;
                    
                    // Check if squares between king and rook are empty
                    for (let c = col - 1; c > 0; c--) {
                        if (board[row][c]) {
                            canCastle = false;
                            break;
                        }
                    }
                    
                    // Check if king passes through check
                    if (canCastle) {
                        const tempBoard = JSON.parse(JSON.stringify(board));
                        tempBoard[row][col] = null;
                        
                        // Check if king passes through check
                        if (wouldSquareBeAttacked(row, col - 1, color, tempBoard) ||
                            wouldSquareBeAttacked(row, col - 2, color, tempBoard)) {
                            canCastle = false;
                        }
                    }
                    
                    if (canCastle) {
                        moves.push({ row: row, col: col - 2, castling: 'queenside' });
                    }
                }
            }
            
            return moves;
        }
        
        // Check if a square would be attacked by any opponent piece
        function wouldSquareBeAttacked(row, col, color, boardState) {
            const opponentColor = color === 'white' ? 'black' : 'white';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece && piece.color === opponentColor) {
                        if (canPieceAttack(r, c, row, col, piece.type, opponentColor, boardState)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Update game information display
        function updateGameInfo() {
            document.getElementById('current-turn').textContent = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
            
            const status = document.getElementById('game-status');
            if (isKingInCheckmate(currentPlayer)) {
                const winner = currentPlayer === 'white' ? 'Black' : 'White';
                status.textContent = `Checkmate! ${winner} wins`;
            } else if (isKingInCheck(currentPlayer)) {
                status.textContent = 'Check!';
            } else if (isStalemate(currentPlayer)) {
                status.textContent = 'Stalemate! Game is a draw';
            } else {
                status.textContent = 'In Progress';
            }
        }
        
        // Update move history display
        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            moveList.innerHTML = '';
            
            // Group moves into pairs
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const moveRow = document.createElement('div');
                moveRow.className = 'move-number';
                moveRow.textContent = moveNumber + '.';
                moveList.appendChild(moveRow);
                
                const whiteMove = document.createElement('div');
                whiteMove.textContent = moveHistory[i];
                moveList.appendChild(whiteMove);
                
                const blackMove = document.createElement('div');
                if (i + 1 < moveHistory.length) {
                    blackMove.textContent = moveHistory[i + 1];
                }
                moveList.appendChild(blackMove);
            }
            
            // Scroll to bottom
            moveList.scrollTop = moveList.scrollHeight;
        }
        
        // Check game status (checkmate, stalemate, etc.)
        function checkGameStatus() {
            if (isKingInCheckmate(currentPlayer)) {
                const winner = currentPlayer === 'white' ? 'Black' : 'White';
                document.getElementById('game-status').textContent = `Checkmate! ${winner} wins`;
            } else if (isStalemate(currentPlayer)) {
                document.getElementById('game-status').textContent = 'Stalemate! Game is a draw';
            }
        }
        
        // Reset the game
        function resetGame() {
            initializeBoard();
        }
        
        // Undo the last move
        function undoMove() {
            if (gameHistory.length > 0) {
                const lastState = gameHistory.pop();
                
                board = lastState.board;
                currentPlayer = lastState.currentPlayer;
                kings = lastState.kings;
                rooks = lastState.rooks;
                enPassantTarget = lastState.enPassantTarget;
                moveHistory = lastState.moveHistory;
                
                selectedPiece = null;
                validMoves = [];
                
                updateBoard();
                updateGameInfo();
                updateMoveHistory();
            }
        }
        
        // AI evaluation functions for simple computer opponent
        function evaluatePiece(piece) {
            if (!piece) return 0;
            
            const pieceValues = {
                'pawn': 1,
                'knight': 3,
                'bishop': 3,
                'rook': 5,
                'queen': 9,
                'king': 0 // King is not assigned value in material evaluation
            };
            
            return pieceValues[piece.type];
        }
        
        function evaluatePosition() {
            let score = 0;
            
            // Material evaluation
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = evaluatePiece(piece);
                        score += piece.color === 'white' ? value : -value;
                    }
                }
            }
            
            // Position evaluation - bonus for controlling center squares
            const centerSquares = [{row: 3, col: 3}, {row: 3, col: 4}, {row: 4, col: 3}, {row: 4, col: 4}];
            for (const square of centerSquares) {
                // Check which pieces attack these squares
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            if (canPieceAttack(row, col, square.row, square.col, piece.type, piece.color, board)) {
                                score += piece.color === 'white' ? 0.1 : -0.1;
                            }
                        }
                    }
                }
            }
            
            // Bonus for development of minor pieces (knights and bishops)
            const whiteDeveloped = 
                board[7][1] === null && // Knight moved
                board[7][2] === null && // Bishop moved
                board[7][5] === null && // Bishop moved
                board[7][6] === null;   // Knight moved
                
            const blackDeveloped = 
                board[0][1] === null && // Knight moved
                board[0][2] === null && // Bishop moved
                board[0][5] === null && // Bishop moved
                board[0][6] === null;   // Knight moved
            
            score += whiteDeveloped ? 0.5 : 0;
            score -= blackDeveloped ? 0.5 : 0;
            
            // Penalty for unmoved center pawns
            if (board[6][3] && board[6][3].type === 'pawn') score -= 0.2;
            if (board[6][4] && board[6][4].type === 'pawn') score -= 0.2;
            if (board[1][3] && board[1][3].type === 'pawn') score += 0.2;
            if (board[1][4] && board[1][4].type === 'pawn') score += 0.2;
            
            return score;
        }
        
        // AI move generation
        function makeAIMove() {
            if (currentPlayer !== 'black') return;
            
            // Collect all possible moves for black
            let allMoves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === 'black') {
                        const moves = getValidMovesForPiece(row, col);
                        for (const move of moves) {
                            allMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                moveDetails: move
                            });
                        }
                    }
                }
            }
            
            // Evaluate moves
            let bestMove = null;
            let bestScore = -Infinity;
            
            for (const move of allMoves) {
                // Create a temporary board to simulate the move
                const tempBoard = JSON.parse(JSON.stringify(board));
                const tempPiece = tempBoard[move.fromRow][move.fromCol];
                
                // Make the move on the temporary board
                tempBoard[move.fromRow][move.fromCol] = null;
                tempBoard[move.toRow][move.toCol] = tempPiece;
                
                // Evaluate the resulting position
                const origBoard = board;
                board = tempBoard;
                const score = -evaluatePosition(); // Negate because we're evaluating from black's perspective
                board = origBoard;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            // Make the best move
            if (bestMove) {
                saveGameState();
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol, bestMove.moveDetails);
            }
        }
        
        // Chess clock functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateClocks() {
            document.getElementById('white-clock').textContent = formatTime(clockTime.white);
            document.getElementById('black-clock').textContent = formatTime(clockTime.black);
            
            // Update active clock
            document.getElementById('white-clock').classList.toggle('active', currentPlayer === 'white');
            document.getElementById('black-clock').classList.toggle('active', currentPlayer === 'black');
        }
        
        function startClock() {
            if (!clockEnabled) return;
            
            // Clear any existing interval
            if (clockIntervalId) {
                clearInterval(clockIntervalId);
            }
            
            activeTimer = currentPlayer;
            
            clockIntervalId = setInterval(() => {
                clockTime[activeTimer]--;
                
                if (clockTime[activeTimer] <= 0) {
                    clearInterval(clockIntervalId);
                    clockTime[activeTimer] = 0;
                    
                    // Game over by timeout
                    const winner = activeTimer === 'white' ? 'Black' : 'White';
                    document.getElementById('game-status').textContent = `Time's up! ${winner} wins`;
                }
                
                updateClocks();
            }, 1000);
        }
        
        function stopClock() {
            if (clockIntervalId) {
                clearInterval(clockIntervalId);
                clockIntervalId = null;
            }
        }
        
        // FEN notation functions
        function exportFEN() {
            let fen = '';
            
            // 1. Piece placement
            for (let row = 0; row < 8; row++) {
                let emptyCount = 0;
                
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    
                    if (piece) {
                        // If there were empty squares before this piece, add the count
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        
                        // Add the piece letter
                        let pieceLetter = '';
                        
                        switch (piece.type) {
                            case 'pawn': pieceLetter = 'p'; break;
                            case 'knight': pieceLetter = 'n'; break;
                            case 'bishop': pieceLetter = 'b'; break;
                            case 'rook': pieceLetter = 'r'; break;
                            case 'queen': pieceLetter = 'q'; break;
                            case 'king': pieceLetter = 'k'; break;
                        }
                        
                        // Uppercase for white pieces
                        if (piece.color === 'white') {
                            pieceLetter = pieceLetter.toUpperCase();
                        }
                        
                        fen += pieceLetter;
                    } else {
                        // Empty square
                        emptyCount++;
                    }
                }
                
                // If there are empty squares at the end of the row
                if (emptyCount > 0) {
                    fen += emptyCount;
                }
                
                // Add row separator (except after the last row)
                if (row < 7) {
                    fen += '/';
                }
            }
            
            // 2. Active color
            fen += ' ' + (currentPlayer === 'white' ? 'w' : 'b');
            
            // 3. Castling availability
            let castling = '';
            
            if (!kings.white.moved) {
                if (!rooks.white.kingside.moved) castling += 'K';
                if (!rooks.white.queenside.moved) castling += 'Q';
            }
            
            if (!kings.black.moved) {
                if (!rooks.black.kingside.moved) castling += 'k';
                if (!rooks.black.queenside.moved) castling += 'q';
            }
            
            fen += ' ' + (castling || '-');
            
            // 4. En passant target square
            let enPassantSquare = '-';
            if (enPassantTarget) {
                enPassantSquare = toAlgebraic(enPassantTarget.row, enPassantTarget.col);
            }
            fen += ' ' + enPassantSquare;
            
            // 5. Halfmove clock (not implemented, using 0)
            fen += ' 0';
            
            // 6. Fullmove number (starting from 1, incremented after Black's move)
            const fullmoveNumber = Math.floor(moveHistory.length / 2) + 1;
            fen += ' ' + fullmoveNumber;
            
            return fen;
        }
        
        function importFEN(fen) {
            // Reset the board
            board = Array(8).fill().map(() => Array(8).fill(null));
            
            const parts = fen.trim().split(' ');
            const positions = parts[0].split('/');
            
            // 1. Piece placement
            for (let row = 0; row < 8; row++) {
                let col = 0;
                
                for (let i = 0; i < positions[row].length; i++) {
                    const char = positions[row][i];
                    
                    if (/\d/.test(char)) {
                        // Skip empty squares
                        col += parseInt(char);
                    } else {
                        // Place a piece
                        const color = char === char.toUpperCase() ? 'white' : 'black';
                        let type = '';
                        
                        switch (char.toLowerCase()) {
                            case 'p': type = 'pawn'; break;
                            case 'n': type = 'knight'; break;
                            case 'b': type = 'bishop'; break;
                            case 'r': type = 'rook'; break;
                            case 'q': type = 'queen'; break;
                            case 'k': type = 'king'; break;
                        }
                        
                        board[row][col] = { type, color };
                        
                        // Update king position
                        if (type === 'king') {
                            kings[color].row = row;
                            kings[color].col = col;
                        }
                        
                        col++;
                    }
                }
            }
            
            // 2. Active color
            currentPlayer = parts[1] === 'w' ? 'white' : 'black';
            
            // 3. Castling availability
            const castling = parts[2];
            
            kings.white.moved = !(castling.includes('K') || castling.includes('Q'));
            kings.black.moved = !(castling.includes('k') || castling.includes('q'));
            
            rooks.white.kingside.moved = !castling.includes('K');
            rooks.white.queenside.moved = !castling.includes('Q');
            rooks.black.kingside.moved = !castling.includes('k');
            rooks.black.queenside.moved = !castling.includes('q');
            
            // 4. En passant target square
            enPassantTarget = null;
            if (parts[3] !== '-') {
                const pos = fromAlgebraic(parts[3]);
                enPassantTarget = { row: pos.row, col: pos.col };
            }
            
            // Reset other game state
            selectedPiece = null;
            validMoves = [];
            moveHistory = [];
            gameHistory = [];
            
            updateBoard();
            updateGameInfo();
            updateMoveHistory();
            updateClocks();
        }
        
        // PGN export function
        function exportPGN() {
            // Create PGN header
            let pgn = '';
            pgn += '[Event "Casual Game"]\n';
            pgn += '[Site "Web Chess"]\n';
            pgn += '[Date "' + new Date().toISOString().split('T')[0].replace(/-/g, '.') + '"]\n';
            pgn += '[Round "1"]\n';
            pgn += '[White "Player"]\n';
            pgn += '[Black "Opponent"]\n';
            pgn += '[Result "*"]\n\n';
            
            // Add moves
            for (let i = 0; i < moveHistory.length; i++) {
                if (i % 2 === 0) {
                    pgn += Math.floor(i / 2) + 1 + '. ';
                }
                
                pgn += moveHistory[i] + ' ';
                
                // Add a newline every 5 full moves
                if (i % 10 === 9) {
                    pgn += '\n';
                }
            }
            
            // Add result
            pgn += '*';
            
            return pgn;
        }
        
        // Save and load game
        function saveGame() {
            const gameState = {
                board: board,
                currentPlayer: currentPlayer,
                moveHistory: moveHistory,
                kings: kings,
                rooks: rooks,
                enPassantTarget: enPassantTarget,
                clockTime: clockTime,
                fen: exportFEN()
            };
            
            localStorage.setItem('chessSavedGame', JSON.stringify(gameState));
            alert('Game saved successfully!');
        }
        
        function loadGame() {
            const savedGame = localStorage.getItem('chessSavedGame');
            
            if (savedGame) {
                const gameState = JSON.parse(savedGame);
                
                board = gameState.board;
                currentPlayer = gameState.currentPlayer;
                moveHistory = gameState.moveHistory;
                kings = gameState.kings;
                rooks = gameState.rooks;
                enPassantTarget = gameState.enPassantTarget;
                clockTime = gameState.clockTime;
                
                // Reset other game state
                selectedPiece = null;
                validMoves = [];
                gameHistory = [];
                
                updateBoard();
                updateGameInfo();
                updateMoveHistory();
                updateClocks();
                
                alert('Game loaded successfully!');
            } else {
                alert('No saved game found!');
            }
        }
        
        // Apply theme
        function applyTheme(themeName) {
            if (!themes[themeName]) return;
            
            currentTheme = themeName;
            const theme = themes[themeName];
            
            // Update CSS variables or directly style elements
            document.documentElement.style.setProperty('--light-square', theme.light);
            document.documentElement.style.setProperty('--dark-square', theme.dark);
            document.documentElement.style.setProperty('--selected', theme.selected);
            document.documentElement.style.setProperty('--check', theme.check);
            
            // Update theme options
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.toggle('active', option.dataset.theme === themeName);
            });
            
            // Force board redraw
            updateBoard();
        }
        
        // Initialize CSS variables
        document.documentElement.style.setProperty('--light-square', themes.classic.light);
        document.documentElement.style.setProperty('--dark-square', themes.classic.dark);
        document.documentElement.style.setProperty('--selected', themes.classic.selected);
        document.documentElement.style.setProperty('--check', themes.classic.check);
        
        // Add event listeners for buttons
        document.getElementById('reset-btn').addEventListener('click', resetGame);
        document.getElementById('undo-btn').addEventListener('click', undoMove);
        // AI button toggle
        let aiEnabled = false;
        document.getElementById('ai-move-btn').addEventListener('click', function() {
            if (aiEnabled) {
                this.textContent = 'AI Move';
                aiEnabled = false;
            } else {
                if (currentPlayer === 'black') {
                    makeAIMove();
                }
                this.textContent = 'Disable AI';
                aiEnabled = true;
            }
        });
        document.getElementById('save-btn').addEventListener('click', saveGame);
        document.getElementById('load-btn').addEventListener('click', loadGame);
        document.getElementById('export-pgn-btn').addEventListener('click', () => {
            const pgn = exportPGN();
            
            // Create a temporary textarea to copy to clipboard
            const textarea = document.createElement('textarea');
            textarea.value = pgn;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            alert('PGN copied to clipboard:\n\n' + pgn);
        });
        document.getElementById('import-fen-btn').addEventListener('click', () => {
            const fen = prompt('Enter FEN notation:', 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
            if (fen) {
                importFEN(fen);
            }
        });
        
        // Add event listeners for theme options
        document.querySelectorAll('.theme-option').forEach(option => {
            option.addEventListener('click', () => {
                applyTheme(option.dataset.theme);
            });
        });
        
        // Initialize the game
        initializeBoard();
    </script>
</body>
</html>